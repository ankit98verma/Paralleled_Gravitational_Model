CS 179: GPU Computing
Project: Generating the Geopotential Model 
Written by: Ankit Verma, Garima Aggarwal

--------------------------------------------------------------------------------
Motivation:
In geophysics, a geopotential model is the theoretical analysis of measuring and calculating the effects of Earth's gravitational field.
Geopotential for homogeneous spheres can be calculated from Newton's law of universal gravitation. But in reality, Earth is not exactly spherical, mainly because of its rotation around the polar axis that makes its shape slightly oblate. If this shape were perfectly known together with the exact mass density ρ = ρ(x, y, z), geopotential could be evaluated with numerical methods to find a more accurate model for Earth's gravitational field. However, the situation is in fact the opposite. By observing the orbits of spacecraft and the Moon, Earth's gravitational field can be determined quite accurately. This estimated gravitational model from various missions has been combined to produce what is now referred to as the spherical harmonics of the gravitational potential.

The higher order gravitational potentials play a very important role for objects of irregular shapes like asteroids. The higher order terms of gravitational potential can change the simulated orbit of the spacecraft around the asteroid. Hence a GPU implementation of calculation of gravitational potential would accelerate the design of space missions(especially the mission in which a irregular body is involved).

--------------------------------------------------------------------------------
Aim:
The aim of this project is to implement the calculation of the gravitational potential map of a celestial body (Earth in our case) in a given space and generate a heat map of the space demonstrating the contributions of higher order terms to the gravitational potential.

--------------------------------------------------------------------------------
Overview of Project/Algorithms:

The project is divided into two parts which are as follows:
1. {Ankit Verma} Generate a set of points uniformly distributed over a sphere of given radius. To perform this task "geodesic polyhedrons" are used. More specially we are using icosahedron to generate a uniformly sampled sphere. An icosahedron is a polygon of equilateral 12 triangles. Following link gives a description of geodesic polyhedrons (including icosahedron): https://en.wikipedia.org/wiki/Geodesic_polyhedron
	
A icosphere of depth 0 is nothing but a icosahedron (each vertex of icosahedron is located at given radius from the origin). A icosphere of depth 1 is made as follows:
	a. Each triangle of the polyhedron (icosahedron) is divided into 4 new triangles by taking a mid point of each edge of the triangle and now each vertex is project on to the radius of the sphere which is being sampled by icosahedron. 
Similarly a icosphere of depth 2 can be made by taking its faces and performing the above operation on them. We increase the depth of icosphere go to depth 1, 2 ... More the depth of the icosphere more the number of samples of the sphere. A icosphere of depth 10 gives more than 10 million points on the sphere!

2. {Garima Aggarwal} Calculation of gravitational potential at the set of points generated. 
The geopotential calculation involves the summation of spherical harmonics. An n-order spherical harmonic would mean a summation of (n+2)*(n+1)/2 terms. The case dealt in this project is when n=20, i.e., every location on the sphere would involve a summation of 231 terms. Hence, as the depth of the icosahedron increases, the number of locations on the sphere increases and so does this calculation. This then becomes time-consuming and hence, requires the need for GPU to produce the gravitational potential model for the entire sphere.

Lastly, producing a heat-map denoting contribution of specific (/all) terms to gravitational potential to visualize the results is 

--------------------------------------------------------------------------------
GPU OPTIMISATION and specifics

There are two modules in the code:

1. Generation of uniform set of points on a sphere (handles by Ankit)

2. Potential Calculation

Potential is calculated at each vertex on the sphere. 
U(r) = Σ(n=0:N) Σ(m=0:n) (C_nm*V_nm + S_nm*W_nm)
where,
	r is the position coordinate of the vertex
	N is the order of geo-potential magnitude (terms which generate the potential model)
	C_nm, S_nm = gravitational potential coefficients, which are stored in resources/GRAVITY_MODEL.txt  
	V, W- are terms to be calculated for the geopotential calculation 
	(NOTE: V_nm,W_nm follow a recursive formula and hence, are interdependent and intra-dependent on previous values of V, W)

Now, for order, N = 20, there are 231 terms of V, W which need to be calculated for the calculation of the geopotential at every vertex.
There are multiple approaches to find the terms and their summation for large number of vertices spread on the globe. Four different ways on GPU have been implemented for the calculation of the potential in src\grav_cuda_potential.cu

(A) naive_gpu_spherical_harmonics

    Naive implementation of he CPU code in GPU.
    Computes the potential for every vertex in each thread.
    Effective when large number of vertices on the sphere- can then use GPU effectively
    Each thread handles each vertex independently
    Number of thread/block = 256

(B) optimal_kernel_gravitational1
    
    Every block is aasigned to every vertex.
    Threads/block = 256;
    Every thread contains calculates one of the 231 terms used in the summation of the potential
    shmem shares stores the 231 terms of the potential calculation
    U[thread_index]  = summation of the 231 terms
    U[thread_index]  = calculated from the reduction method #3
    This method should give improved computational time when number of vertices on the sphere is small, even
    though it wouldnt be a huge time savior.
    In case of small number of vertices, GPU overload happens because of 256 threads assigned to each vertex.
    No shared memory for V[21*21], W[21*21].
    Max shared memory: 256*4bytes = 1KB
    Drawback: Not very effective for higher number of vertices
     
(c) optimal_kernel_gravitational2
	
    Every block is assigned to every vertex.
    Threads/block = 256; %256 threads for reduction summation
    Every thread contains calculates one of the 231 terms used in the summation of the potential
    shmem shares stores the 231 terms of the potential calculation
    U[thread_index]  = summation of the 231 terms
    U[thread_index]  = calculated from the reduction method #3
    This method should give improved computational time when number of vertices on the sphere is small, even
    though it wouldnt be a huge time savior.
    In case of small number of vertices, GPU overload happens because of 256 threads assigned to each vertex.
    Shared memory for V[21*21], W[21*21].
    Max shared memory: (256 + 462 + 462)*4bytes ~ 4.7KB
    Shared memory for V,W. Shared across threads in a block.
    Advantages: Reduces the computational time immensely for less number of vertices.
UNLIKE (B), (C) has shared memory for V,W which is shared across all threads in the block

(D) optimal_kernel_gravitational3

    Every block is assigned to 16 consecutive vertices.
    Threads/block = 32;
    First 16 threads conpute V for the 16 vertices.
    Next 16 threads in the block compute W for the 16 vertices
    This method should give improved computational time when fairly large number
    of vertices on the sphere though it wouldnt be a huge time savior.
    Shared memory for VW[21*22*16]
    Max shared memory: (21*22*16)*4bytes ~ 28.875KB < 48KB
    Shared memory for V,W. Shared across threads in a block.
    Advantages: Reduces the computational time immensely for fairly large number of vertices.
    Drawback: Thread warping because first 16 threads compute different from next 16 threads in the block

    WHY 32 threads only::: Limited by the Shared memory

(E) optimal_kernel_gravitational4

    Every block is assigned to 32 consecutive vertices.
    Threads/block = 64;
    First 16 threads conpute V for the 16 vertices.
    Next 16 threads in the block compute W for the 16 vertices
    This method should give improved computational time when fairly large number
    of vertices on the sphere though it wouldnt be a huge time savior.
    Shared memory for VW[21*22*32]
    Max shared memory: (21*22*32)*4bytes ~ 57.75KB < 64KB
    NOTE:::::::::: This would work if the shared memory can be expanded to 64 KB.
    Shared memory for V,W. Shared across threads in a block.
    Advantages: Reduces the computational time immensely for fairly large number of vertices.
                No Thread warping because 32 threads do the same action
                Couldnt verify due to limited shared memory :(


A COMPARISON ON THE COMPUTATIONAL RUN TIME on potential

vertice 	Naïve			optimal1		optimal 2		optimal 3	
count		Blocks	Time		Blocks	Time		Blocks	Time		Blocks	Time

42		1	7.433728	42	6.94864		42	0.250816	3	0.845152
162		1	7.442624	162	6.878912	162	0.433888	11	0.843264
642		3	7.10624		642	8.699712	642	1.957888	41	0.834432
2562		11	7.147488	2562	13.666816	2562	5.109856	161	2.39392
10242		41	7.199264	10242	35.507679	10242	15.647424	641	7.067584
40962		161	9.329792	40962	117.135902	40962	51.400257	2561	28.049055
163842		641	17.600416	65535	NA		65535	NA		10241	104.715454
655362		2561	63.609		65535	NA		65535	NA		40961	412.380188
2621442		10241	205.367		65535	NA		65535	NA		65535	NA
10485762	40961	798.1147	65535	NA		65535	NA		65535	NA
41943042	65535	3144.47		65535	NA		65535	NA		65535	NA

--------------------------------------------------------------------------------
FILE/CODE STRUCTURE

Following is the file and code structure:

CPU_Demo
│   README  -> The README file of the project containing the details of the prject and instructions
└───Code
    │   grav_run    -> The executable file for CPU demo
    │   Makefile    -> The make file of the project, usage: make clean all
    │
    ├───bin
    │       cuda.o              -> Cuda object fle
    │       grav_cpu.cpp.o      -> CPU code object file
    │       grav_cuda.cu.o      -> Cuda file object
    │       grav_cuda_potential.cu.o      -> Cuda file object
    │       grav_run.cpp.o      -> CPU demo object file
    │       ta_utilities.cpp.o  -> TA utitlities object file
    │
    ├───resources
    │       EGM_jared_20.txt            -> Reference data (un-used at the moment)
    │       EGM_jared_20_only_data.txt  -> Reference data (un-used at the moment)
    │       GRAVITY_MODEL.txt           -> Contains the coefficients of spherical harmonics (used)
    │       jared_EGM20_model.csv       -> Reference data (un-used at the moment)
    │       potential_time.xlsx       	-> Contains the computational time for different GPU potential kernels
    │
    ├───results
    │       cpu_edges.csv           -> The edges of icosphere
    │       heatmap_2.png           -> A 2D heatmap of geopotential
    │       heatmap_3.png           -> A 3D heatmap of geopotential
    │       output_potential.mat    -> Data containing the geo potentials
    │       vertices.csv            -> The vertices of icosphere
    │
    ├───src
    │       cuda_calls_helper.h     -> The cuda call helper file
    │       cuda_header.cuh         -> The cuda header
    │       grav_cpu.cpp            -> The CPU code of the project
    │       grav_cpu.hpp            -> Contains the CPU modules declarations and is the header file for grav_cpu.cpp
    │       grav_cuda.cu            -> The GPU code for generation of icosphere (Ankit)
    │       grav_cuda_potential.cu  -> The GPU code for calculation of potential terms (Garima)
    │       grav_cuda.cuh           -> Contains the GPU modules declarations and is the header file for grav_cuda.cu
    │       grav_run.cpp            -> The code containing the "main( , )" function. It runs both the CPU and GPU modules of the code.(GPU code has been commented for CPU demo).
    │       helper_cuda.h           -> Helper file for GPU program
    │       ta_utilities.cpp        -> The TA's utility functions (unused at the moment)
    │       ta_utilities.hpp        -> The header file for TA's utility functions (unused at the moment)
    │
    └───utilities
            heat_map.m              -> Matlab file to generate heatmaps
            visulaize_icosphere.m   -> Matlab file to visualize icosphere

--------------------------------------------------------------------------------
INSTRUCTIONS on how to run the CPU demo

Please follow the following instructions:

1. Go into the "Code" folder by using "cd Code"
2. Build the project by running "make clean all" (without quotes). This would create object files in "bin/" folder and creates three executable files named "cpu_run" (which executes only CPU version of the code), "gpu_run" (which executes only GPU version of the code) and "both_run" (which executes both CPU and GPU version of the code and also verifies the GPU code against the CPU code. It verifies the icosphere generated by Ankit and the potential calculated by Garima) .
3. Run the code as follows:
	./cpu_run <depth of icosphere> <verbose 0/1> <Icosphere optimization level {0 or 1}>  <Geopotential optimization level {0 to 3}>
	./gpu_run <depth of icosphere> <verbose 0/1> <Icosphere optimization level {0 or 1}>  <Geopotential optimization level {0 to 3}>
	./both_run <depth of icosphere> <verbose 0/1> <Icosphere optimization level {0 or 1}>  <Geopotential optimization level {0 to 3}>

	The code will generate icospheres from depth 0 to the value provided in argument "depth of icosphere". For each depth it will calculate the gravitational potential. (Please check the email sent to you for visualization of gravity potential). If verbose is set to 1 then a detailed messages will be printed else only essential messages will be printed. Icosphere Optimisation level can be either 0 (Naive Implementation) OR 1 (Optimal implementation). Geopotential Optimisation level can be any integer from 0 to 3. 0 represents Naive Implementation while 1,2,3 represent different Optimal implemnetations for potential calculation as described above. Note Optimisation level 4 has also been coded in the grav_cuda_potential.cu but it tends to exceed the shared memory of 48KB. That kernel would work if the shared memory can be expanded to 64KB.

	The CPU takes quite some time to run the program for more than 9. Hence it is recommended to give value for "depth of icosphere" less than 10. We have provided the output of the code till depth 10 in the next section.


--------------------------------------------------------------------------------
Output:
Since for large values of depth of icosphere the CPU takes a lot of time to run hence we are providing the results of running the "grav_run" till depth level 10, which is as follows:

**********************************************************************************
|  Depth |                        |       CPU time (ms)   |                      |
|--------|------------------------|-----------------------|----------------------|
|        |Icosphere (ms){Ankit}   |Potential (ms){Garima} |    Total (ms)        |
|    0   |       0.013856         |       0.341984        |        0.35584       |
|    1   |       0.055328         |         1.1599        |        1.21523       |
|    2   |        0.18416         |        4.44883        |        4.63299       |
|    3   |       0.815232         |        14.5983        |        15.4135       |
|    4   |        4.62538         |        58.1904        |        62.8158       |
|    5   |         27.998         |         232.07        |        260.068       |
|    6   |        178.649         |        939.229        |        1117.88       |
|    7   |        1168.84         |        3713.31        |        4882.14       |
|    8   |        8122.81         |        14925.8        |        23048.6       |
|    9   |        58224.5         |        59715.9        |         117940       |
|    10  |        436761          |        238408         |         675169       |
**********************************************************************************



As shown above the total time for CPU goes well above 10 mintues for depth 10.
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
Future Work:
Similar to using the spherical harmonic coefficients for Geopotential model, similar model can be generated for other known bodies in space, like asteroids, whose geopotential model would be interesting to study in the field of astrodynamics.
We can also compute the gravitational acceleration just like gravitational potential which can be used in integrators for trajectory design.

--------------------------------------------------------------------------------
References:
Geopotential model: Satellite Orbits, by Oliver Montebruck
Geodesic polyhedron: https://en.wikipedia.org/wiki/Geodesic_polyhedron
